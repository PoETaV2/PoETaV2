"""

"""
import os
import re
import numpy as np
import pandas as pd
from sklearn.metrics import f1_score
from lm_eval.base import rf, PromptSelectionTask
from ..metrics import mean
from datasets import load_dataset
import collections

_CITATION = """
@inproceedings{vargas-etal-2022-hatebr,
    title = "{H}ate{BR}: A Large Expert Annotated Corpus of {B}razilian {I}nstagram Comments for Offensive Language and Hate Speech Detection",
    author = "Vargas, Francielle  and
      Carvalho, Isabelle  and
      Rodrigues de G{\'o}es, Fabiana  and
      Pardo, Thiago  and
      Benevenuto, Fabr{\'\i}cio",
    editor = "Calzolari, Nicoletta  and
      B{\'e}chet, Fr{\'e}d{\'e}ric  and
      Blache, Philippe  and
      Choukri, Khalid  and
      Cieri, Christopher  and
      Declerck, Thierry  and
      Goggi, Sara  and
      Isahara, Hitoshi  and
      Maegaard, Bente  and
      Mariani, Joseph  and
      Mazo, H{\'e}l{\`e}ne  and
      Odijk, Jan  and
      Piperidis, Stelios",
    booktitle = "Proceedings of the Thirteenth Language Resources and Evaluation Conference",
    month = jun,
    year = "2022",
    address = "Marseille, France",
    publisher = "European Language Resources Association",
    url = "https://aclanthology.org/2022.lrec-1.777",
    pages = "7174--7183",
    abstract = "Due to the severity of the social media offensive and hateful comments in Brazil, and the lack of research in Portuguese, this paper provides the first large-scale expert annotated corpus of Brazilian Instagram comments for hate speech and offensive language detection. The HateBR corpus was collected from the comment section of Brazilian politicians{'} accounts on Instagram and manually annotated by specialists, reaching a high inter-annotator agreement. The corpus consists of 7,000 documents annotated according to three different layers: a binary classification (offensive versus non-offensive comments), offensiveness-level classification (highly, moderately, and slightly offensive), and nine hate speech groups (xenophobia, racism, homophobia, sexism, religious intolerance, partyism, apology for the dictatorship, antisemitism, and fatphobia). We also implemented baseline experiments for offensive language and hate speech detection and compared them with a literature baseline. Results show that the baseline experiments on our corpus outperform the current state-of-the-art for the Portuguese language.",
}
"""

_manual_examples=[

]

class HateBR_Binary(PromptSelectionTask):
    VERSION = 0
    DATASET_PATH = "ruanchaves/hatebr"
    DATASET_NAME = None

    manual_examples = _manual_examples

    KEYS_TO_INDEX = ['instagram_comments']
    KEY_TO_BALANCE = 'offensive_language'
    NUM_CLASSES = 2
    SEARCHER_K = 600

    def download(self, data_dir=None, cache_dir=None, download_mode=None):
        """ Dowloading the dataset requires the use of an API key. To use the 
        dataset for academic purpose, please contact the corresponding author 
        Henrico Brum. The dataset is originally in TSV format, and comes with 
        a parsing code that converts to a JSON file.
        """
        dataset = load_dataset(self.DATASET_PATH, )

        self.dataset = dataset

        #exemplo
        #{'instagram_comments': 'Mais um lixo', 'offensive_language': True, 'offensiveness_levels': 1, 'antisemitism': False, 'apology_for_the_dictatorship': False, 'fatphobia': False, 'homophobia': False, 'partyism': False, 'racism': False, 'religious_intolerance': False, 'sexism': False, 'xenophobia': False, 'offensive_&_non-hate_speech': True, 'non-offensive': False, 'specialist_1_hate_speech': False, 'specialist_2_hate_speech': False, 'specialist_3_hate_speech': False}

    def has_training_docs(self):
        return True

    def has_validation_docs(self):
        return True

    def has_test_docs(self):
        return True

    def training_docs(self):
        return self.dataset["train"]

    def validation_docs(self):
       return self.dataset["test"]

    def test_docs(self):
        return self.dataset["test"]

    def doc_to_text(self, doc):
        return f"Mensagem: \"{doc['instagram_comments']}\".\nResposta:"

    def doc_to_target(self, doc):
        answer="ofensiva" if doc['offensive_language'] == True else "inofensiva"
        return " " + answer

    def construct_requests(self, doc, ctx):
        """ Uses RequestFactory to construct Requests and returns an iterable of 
        Requests which will be sent to the LM.

        :param doc:
            The document as returned from training_docs, validation_docs, or test_docs.
        :param ctx: str
            The context string, generated by fewshot_context. This includes the natural 
            language description, as well as the few shot examples, and the question
            part of the document for `doc`. 
        """
        ll_negativa, _ = rf.loglikelihood(ctx, " inofensiva") 
        ll_positiva, _ = rf.loglikelihood(ctx, " ofensiva") 
        return ll_negativa, ll_positiva
    
    def process_results(self, doc, results):
        """Take a single document and the LM results and evaluates, returning a 
        dict where keys are the names of submetrics and values are the values of 
        the metric for that one document

        :param doc:
            The document as returned from training_docs, validation_docs, or test_docs.
        :param results:
            The results of the requests created in construct_requests.
        """
        gold = 0 if doc['offensive_language'] == False else 1
        pred = np.argmax(results)

        return {
            "acc": (pred == gold),
            "f1-macro": (pred, gold),
            "f1-weighted": (pred, gold),
        }

    @classmethod
    def macro_f1(cls, items):
        preds, golds = zip(*items)
        preds = np.array(preds)
        golds = np.array(golds)
        label_set = set(golds)
        macro_f1 = f1_score(golds, preds, average='macro', 
                        labels=list(label_set))
        return macro_f1 * 100.0

    @classmethod
    def weighted_f1(cls, items):
        preds, golds = zip(*items)
        preds = np.array(preds)
        golds = np.array(golds)
        label_set = set(golds)
        weighted_f1 = f1_score(golds, preds, average='weighted', 
                        labels=list(label_set))
        return weighted_f1 * 100.0

    def aggregation(self):
        """
        :returns: {str: [float] -> float}
            A dictionary where keys are the names of submetrics and values are 
            functions that aggregate a list of metrics
        """
        return {
            "acc": mean,
            "f1-macro": self.macro_f1,
            "f1-weighted": self.weighted_f1,
        }

    def higher_is_better(self):
        """
        :returns: {str: bool}
            A dictionary where keys are the names of submetrics and values are 
            whether a higher value of the submetric is better
        """
        return {
            "acc": True,
            "f1-macro": True,
            "f1-weighted": True,
        }


class HateBR_Binary_Greedy(HateBR_Binary):
    def construct_requests(self, doc, ctx):
        """Uses RequestFactory to construct Requests and returns an iterable of
        Requests which will be sent to the LM.
        :param doc:
            The document as returned from training_docs, validation_docs, or test_docs.
        :param ctx: str
            The context string, generated by fewshot_context. This includes the natural
            language description, as well as the few shot examples, and the question
            part of the document for `doc`.
        """
        continuation = rf.greedy_until(ctx, ['\n'])
        return continuation

    def process_results(self, doc, results):
        """Take a single document and the LM results and evaluates, returning a
        dict where keys are the names of submetrics and values are the values of
        the metric for that one document
        :param doc:
            The document as returned from training_docs, validation_docs, or test_docs.
        :param results:
            The results of the requests created in construct_requests.
        """
        gold = self.doc_to_target(doc).strip().lower()
        pred = results[0].strip().lower()
        
        regex_str='(inofensiva|ofensiva)'
        # get first match
        match = re.search(regex_str, pred)
        if match:
            regex_pred = match.group(1)
        else:
            regex_pred = pred
        if pred==gold:
            acc=1
        elif regex_pred==gold:
            acc=1
        else:
            acc=0
        
        debug_info={
            "gold":gold,
            "pred":pred,
            "regex_pred":regex_pred
        }

        return {
            "acc": acc,
            "f1-macro": (pred, gold),
            "f1-weighted": (pred, gold),
            "debug_info":debug_info
        }
    


class HateBR_multiclass(HateBR_Binary):
    class_to_string_mapping = {
        "fatphobia": "gordofobia",
        "homophobia": "homofobia",
        "religious_intolerance": "intolerância religiosa",
        "sexism": "sexismo",
        "offensive_&_non-hate_speech": "somente ofensivo",
        "apology_for_the_dictatorship": "apologia à ditadura",
        "antisemitism": "antissemitismo",
        "xenophobia": "xenofobia",
        "partyism": "partidarismo",
        "racism": "racismo",
        "non-offensive": "não ofensivo"
    }

    def doc_to_text(self, doc):
        return f"Mensagem: \"{doc['instagram_comments']}\".\nClassificação:"

    def doc_to_target(self, doc):

        for possible_class in self.class_to_string_mapping:
            if doc[possible_class]:
                return " " + self.class_to_string_mapping[possible_class]
        
    def construct_requests(self, doc, ctx):
        """ Uses RequestFactory to construct Requests and returns an iterable of 
        Requests which will be sent to the LM.

        :param doc:
            The document as returned from training_docs, validation_docs, or test_docs.
        :param ctx: str
            The context string, generated by fewshot_context. This includes the natural 
            language description, as well as the few shot examples, and the question
            part of the document for `doc`. 
        """

        ll_requests=[]
        
        for possible_class in self.class_to_string_mapping:
            ll_request, _ = rf.loglikelihood(ctx, f" {self.class_to_string_mapping[possible_class]}")
            ll_requests.append(ll_request)

        return ll_requests
    
    def process_results(self, doc, results):
        """Take a single document and the LM results and evaluates, returning a 
        dict where keys are the names of submetrics and values are the values of 
        the metric for that one document

        :param doc:
            The document as returned from training_docs, validation_docs, or test_docs.
        :param results:
            The results of the requests created in construct_requests.
        """
        for i,possible_class in enumerate(self.class_to_string_mapping):
            if doc[possible_class]:
                gold = i

        pred = np.argmax(results)

        return {
            "acc": (pred == gold),
            "f1-macro": (pred, gold),
            "f1-weighted": (pred, gold),
        }

class HateBR_multiclass_Greedy(HateBR_multiclass):
    def construct_requests(self, doc, ctx):
        """Uses RequestFactory to construct Requests and returns an iterable of
        Requests which will be sent to the LM.
        :param doc:
            The document as returned from training_docs, validation_docs, or test_docs.
        :param ctx: str
            The context string, generated by fewshot_context. This includes the natural
            language description, as well as the few shot examples, and the question
            part of the document for `doc`.
        """
        continuation = rf.greedy_until(ctx, ['\n'])
        return continuation

    def process_results(self, doc, results):
        """Take a single document and the LM results and evaluates, returning a
        dict where keys are the names of submetrics and values are the values of
        the metric for that one document
        :param doc:
            The document as returned from training_docs, validation_docs, or test_docs.
        :param results:
            The results of the requests created in construct_requests.
        """
        gold = self.doc_to_target(doc).strip().lower()
        pred = results[0].strip().lower()
        
        
        debug_info={
            "gold":gold,
            "pred":pred
        }
        

        return {
            "acc": (pred == gold),
            "f1-macro": (pred, gold),
            "f1-weighted": (pred, gold),
            "debug_info":debug_info
        }
    
        
